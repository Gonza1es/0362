#include <iostream>
#include <locale>
#include <cmath>
using namespace std;

void menu();//просто меню
int GetAllSubsets(int [], int);//получение всех подмножеств данного множества
int GetOnlyKSubsets(int [], int, int);//получение к-элементных подмножеств
int GetSubsetsWithNum(int [], int, int);//получение множеств, содержащих определенный элемент
void MakingExtraArray(int [], int [], int, int);//получение дополнительного массива
int CountingBits(int);//подсчет количества единиц в двоичной записи числа

int main()
{
    setlocale(LC_ALL, "rus");
    int choice, range = 0;
    menu();
    cin >> choice;
    switch (choice)
    {
       case 1:
           {
               cout << "Пожалуйста, введите количество элементов в множестве" << endl;
               cin >> range;
               int sub[range];
               cout << "Пожалуйста, введите элементы множества" << endl;
               for (size_t i = 0; i < range; i++)
               {
                   cin >> sub[i];
               }
               GetAllSubsets(sub,range);
               break;
           }
       case 2:
           {
               cout << "Пожалуйста, введите количество элементов в множестве" << endl;
               cin >> range;
               int sub[range];
               cout << "Пожалуйста, введите элементы множества" << endl;
               for (size_t i = 0; i < range; i++)
               {
                   cin >> sub[i];
               }
               int k;
               cout << "Пожалуйста, введите количество элементов в искомых подмножествах" << endl;
               cin >> k;
               GetOnlyKSubsets(sub,range,k);
               break;
           }
       case 3:
           {
               cout << "Пожалуйста, введите количество элементов в множестве" << endl;
               cin >> range;
               int sub[range];
               cout << "Пожалуйста, введите элементы множества" << endl;
               for (size_t i = 0; i < range; i++)
               {
                   cin >> sub[i];
               }
               int x;
               cout << "Пожалуйста, введите число:" << endl;
               cin >> x;
               GetSubsetsWithNum(sub,range,x);
               break;
           }
       default: cout << "Было введено неверное число" << endl; break;
    }
    return 0;
}
//просто меню, ничего необычного
void menu()
{
    cout << "Пожалуйста, выберите необходимое действие:" << endl;
    cout << "1 - получить все подмножества данного множества" << endl;
    cout << "2 - получить все к-элементные подмножества" << endl;
    cout << "3 - получить все подмножества, содержащие элемент\n" << endl;
}
/*Функция GetAllSubsets получает на вход введеное с клавиатуры множество (в данном случае массив sub) и количество элементов в этом множестве(N);
Функция GetAllSubsets находит все подмножества введеного с клавиатуры множества;
если функция отработала корректно, в конце вернется ноль
*/
int GetAllSubsets(int sub[], int N)
{
    int deg;
    deg = pow(2, N);//количество подможеств будет определяться как 2 в степени N(количество элементов множества)
    for (size_t i = 0; i < deg; i++)//перебор масок (представленных в битовом виде)
    {
        cout << "{";
        for (size_t j = 0; j < N; j++)//перебор битов
                    if (i & (1 << j))//при условии, что j-й бит установлен, будет выводиться j-й элемент множества
                     cout << sub[j];
        cout << "}" << endl;
    }
    return 0;
}
/*Функция GetOnlyKSubsets получает на вход введеное с клавиатуры множество (в данном случае массив sub),количество элементов в этом множестве(N)
и количество элементов в искомых подмножествах(К);
Функция GetOnlyKSubcets находит все подмножества, содержащие определенное количество элементов;
если функция отработала корректно, в конце вернется ноль
*/
int GetOnlyKSubsets(int sub[], int N, int K)
{
    if (K > N) {cout << "Что-то пошло не так" << endl; return 0;}
    if (K == 0) cout << "{}"<< endl;
    int deg;
    deg = pow(2, N);//количество подможеств будет определяться как 2 в степени N(количество элементов множества)
    int score[deg];
    for (int i = 1; i < deg; i++)//перебор масок (представленных в битовом виде)
    {
        score[i] = CountingBits(i);
        if(score[i] == K){
        cout << "{";
        for (int j = 0; j < N; j++)//перебор битов
                    if (i & (1 << j))//при условии, что j-й бит установлен, будет выводиться j-й элемент множества
                      {
                          cout << sub[j];
                      }
        cout << "}" << endl;
        }
    }
    return 0;
}
/*Функция CountingBits считает количество единиц в двоичной записи числа;
Функция на вход принимает целое число x(в данном случае, номер подмножества)*/
int CountingBits(int x)
{
    int b = 0;
    while (x > 0)
    {
        if (x % 2 != 0) b++;
        x /= 2;
    }
    return b;
}
/*Функция GetSubsetsWithNum получает на вход введеное с клавиатуры множество (в данном случае массив sub), количество элементов в этом множестве(N)
и число, которое должно присутствовать в подмножествах;
Функция GetSubsetsWithNum находит все подмножества (введеного с клавиатуры множества), содержащие определенный элемент;
если функция отработала корректно, в конце вернется ноль
*/
int GetSubsetsWithNum(int sub[], int N, int X)
{
    int p[N-1];//дополнительный массив для сохранения чисел, не равных введёному
    int deg;
    MakingExtraArray(sub, p, N, X);
    //проводим ровно те же операции, что и в нахождении подмножеств множества
    deg = pow(2, N-1);
    for (size_t i = 0; i < deg; i++)
    {
        cout << "{" << X;
        for (size_t j = 0; j < N-1; j++)
                    if (i & (1 << j)) cout << p[j];
        cout << "}" << endl;
    }
    return 0;
}
/* функция MakingExtraArray находит все числа данного множества, не равные введёному, и составляет дополнительный массив из этих чисел;
sub[] - изначальное множество; p[] - дополнительный массив; num - количество элементов в изначальном множестве;
arg - введеное число (число, с которым мы должны найти все подмножества);
*/
void MakingExtraArray(int sub[], int p[], int num, int arg)
{
    int ch;//просто переменная, чтобы не потерять элемент массива
    for (size_t i = 0; i < num; i++)//в нашем изначальном множестве находи элемент, равный введёному, и меняем его с последним
    {
        if (sub[i] == arg)
        {
            ch = sub[i];
            sub[i] = sub[num-1];
            sub[num-1] = ch;
        }
    }
    for (size_t i = 0; i < num-1; i++)//помещаем числа в дополнительный массив
    {
        p[i] = sub[i];
    }
}
